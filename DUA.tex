\documentclass{article}
\usepackage[utf8]{inputenc}
\begin{document}
\small
\section{Grundlagen}
\subsection{Invariante}
\begin{itemize}
\item Vorm ersten Durchlauf erf{\"u}llt sein (Initialisierung, Induktionsanfang)
\item Muss bei jedem Schleifendurchlauf erhalten bleiben (Erhaltng, Induktionsschritt)
\item Invar nach Beendigung der Schleife zeigt Korrektheit (Terminierung)
\end{itemize}


\subsection{allgemeines Mastertheorem}

\begin{itemize}
\item $a,b,d,q \geq  1$
\item $T (n) \leq \left\{
\begin{array}{ll}
d & n\leq q \\
a\cdot T(\frac{n}{b}) +f(n) & \, n>q \\
\end{array}
\right. $
\end{itemize}
\begin{tabular}{l l}
$f(n) = O(n^{log_b(a)-\epsilon}) \; mit \; \epsilon > 0$ & $T(n) = O(n^{log_b(a)}) $\\
$f(n) = \Theta(n^{log_b(a)}) $ & $T(n) = O(n^{log_b(a)} log(n)) $\\
$f(n) = \Omega(n^{log_b(a)+\epsilon}) \; mit \; \epsilon > 0,$ & $T(n) = \Theta(f(n)) $\\
$a\cdot f(\frac{n}{b}) \leq \delta  \cdot f(n), \delta < 1, n \to \infty$ & \\
\end{tabular}

\section{ O-Notation}
\subsection{Definition}
\begin{itemize}
\item $f = O(g) \Leftrightarrow  \exists  c> 0 \exists n_0 \in N \; \forall n \geq n_0 : f(n) \leq c g(n)$ \\ (f w{\"a}chst asymptotisch h{\"o}chstens so schnell wie g)
\item $f = \Omega(g) \Leftrightarrow g = O(f)$ \newline (f wachst asymptotisch mindestens so schnell wie g)

\item f = $\Theta (g) \Leftrightarrow f = O(g) \; und \; g = O(f)$ \newline
(f und g wachsen asymptotisch gleich schnell)
\item $f = o(g) \Leftrightarrow \forall c > 0 \; \exists n_0 \in N \forall n\geq n_0 : f(n) < c g(n)$ \\ 
$ \lim\limits_{n \to \infty}\frac{f(n)}{g(n)} = 0 $\newline (f w{\"a}chst asymptotisch langsamer als g)
\item $f = \omega(g) \Leftrightarrow g = o(f)$ \newline (f w{\"a}chst asymptotisch langsamer als g)
\end{itemize}
\subsection{Eigenschaften}
\begin{itemize}
\item $f = o(g) \Rightarrow f = O(g)$
\item $f = o(g) \; und \;  h = o(g) \Rightarrow f+h = o(g) (auch O, \Omega, \omega, \Theta)$
\item $f = o(g) \; und \;  h = o(g) \Rightarrow f\cdot h = o(g^2) (auch O, \Omega, \omega, \Theta)$
\end{itemize}
\subsection{Reihenfolge}
$c < log(n) < n^{\frac{1}{k}} < n < n log(n) < n^2 < n^k < 2^n$
\section{Sortieralgorithmen}
\subsection {Bubblesort}
\begin{itemize}
\item Jeden Durchlauf wird das gr{\"o}\ss te Element auf die n-ite Stelle getauscht. Jeder Vergleich ggf ein Swap.

\end{itemize}

\subsection{Insertionsort}
\begin{itemize}
\item Key wird in sortiertes Array eingeordnet. Key wird gemerkt, falls kleiner wird das g{\"o}\ss ere Element auf Pos von Key kopiert aber Key wird erst kopiert, wenn die richtige Stelle gefunden worden ist.
\end{itemize}

\subsection{Mergesort}
\begin{itemize}
\item Teile Array bis auf ein Element Array und sortiere beim rekursiven zusammenf{\"u}gen. Geteilt wird p bis q, q+1 bis r. \\
Merge vergleicht erste Pos von den Arrays und f{\"u}gt immer das kleinere ins Zielarray ein.

\end{itemize}

\subsection{Quicksort(A,p,r)}
\begin{itemize}
\item Teile Array nach Pivotelement und f{\"u}ge Pivot dann an Grenze ein. Dann partition bis q-1 und 
\end{itemize}

\section{Heap}
\subsection{Definition}

\begin{itemize}
\item $ Heap := A[i] \geq A[2i] und A[i] \geq A[2i+1]$ 
\item jeder Knoten hat mindestens so gro\ss en Wert wie seine Kinder 
\item Wird als bin{\"a}rer Baum dargestellt.
\end{itemize}

\subsection{Eigenschafen}
\begin{itemize}
\item Baumtiefe $\lfloor log(n)\rfloor$
\item $A[\lfloor \frac{n}{2} \rfloor +1] \; bis \; A[n]$ sind Kinder
\item Maximum ist die Wurzel A[1]
\end{itemize}
\subsection{Heapify}
\begin{itemize}
\item Tausche mit gr{\"o}\ss tem Kind
\item wird auf getauschten Knoten erneut aufgerufen bis er richtit steht
\end{itemize}
\subsection{Build-Heap}
\begin{itemize}
\item Bei uns meist MaxHeap
\item Heapify auf $A[\lfloor \frac{n}{2} \rfloor] \; downto  \;A[1]$
\item $BC: \Theta(n)\; AV:\Theta(n)\; WC: \Theta(n)\;$
\item \#Vertauschungen $\leq \sum_{i=1}^{\lfloor \frac{n}{2} \rfloor} (log(n) -log(i))$
\item \#Vergleiche $\leq$ 2 \#Vertauschungen
\end{itemize}

\subsection{Heap-Sort}
\begin{itemize}
\item Build-Heap
\item Sort-Heap \\
$Vertausche A[1] und A[i]$\\
Danach Heapify(A[i ... i-1])\\
\end{itemize}

\subsection{Bucket-Sort}
\begin{itemize}
\item H{\"a}nge $a_j$ an Liste L[$a_j$] an. Gebe alle Listen aus
\end{itemize}

\section{Dynamische Arrays}
\begin{itemize}
\item Falls Array A nicht mehr ausreicht (n>w). Verdoppel Array 
\item Falls $\frac{1}{4} \; und \; n>0$ Halbiere Array
\end{itemize}

\section{Stack}
\begin{itemize}
\item Empty(S), Pop(S), Push(S), Top(S)(Pos)
\end{itemize}

\section{Queue}
\begin{itemize}
\item Enqueue,Dequeue, Head(Q), Tail(Q)(erste freie Pos)
\item falls Array vonn starte bei 1, falls frei
\end{itemize}

\section{Doppelt verkettete Listen}
\begin{itemize}
\item Head(L), Insert(L,x)(h{\"a}ngt vorne dran), Remove(L,x)
\item key(x), next(x), prev(x)
\item falls next(x) = nil, x letztes Element
\end{itemize}

\section{Skiplisten}
\begin{itemize}
\item verschiedene Niveaus 
\item perfekte hat $ \lceil  log(n)\rceil$ Niveaus (erm{\"o}glicht bin{\"a}re Suche)
\item left(v), right(v), down(v), up(v), Search(L,x), Insert(L,v) (mit RandomHight)
\item Niveau 0, wo jeder Knoten ist ($2^0$)
\item Niveau k behinaltet jeden $2^k$-ten Knoten
\end{itemize}

\section{Bin{\"a}re Suchb{\"a}ume}
\subsection{Bin{\"a}re Suchb{\"a}ume}
\begin{itemize}
\item lc[x], rc[x], p[x],root[x]
\item Inorder-Tree-Walk(x) gebe Knoten sortiert, nach abgeben, aus. \\ Gehe am Ende von ganz rechts zur Wurzel zur{\"u}ck. $\Theta(n)$
\item Baumsuche(x,k) meist mit x = root[T]
\item Delete(x), x hat 2 Kinder, Nachfolger von x wird verschoben, ggf wiederholen
\end{itemize}

\subsection{Balancierte Suchb{\"a}ume (AVL)}
\begin{itemize}
\item H{\"o}he h{\"o}chstens $2log(n+1)-2$
\item Rotation {\"a}ndern nur H{\"o}he
\item Rechtsrota(T,x),Linksrota(T,x)
\item bei delete Vorgänger auswählen
\end{itemize}

\section{Hashing}
\subsection{Geschlossene Adressierung}
\begin{itemize}
\item Kollisionsuafl{\"o}sung durch Listen
\item Suchen/L{\"o}schen AV: $\Theta(1+\alpha)$, Falls  m= $\Theta(n)$ $\Theta(1)$
\end{itemize}


\subsection{Offene Adressierung}
\begin{itemize}
\item (n{\"a}chste) freie Stelle in der Hashtabelle
\item Lineares Hashing: $h(k,i) = (h'(k) +i) mod \; m$
\item Quadratisches Hashing: $h(k,i) = (h'(k) +c_1i+ c_2 i^2) mod \; m$
\item Delete problematisch, deshalb offene Adressierung bei Anwendungen ohne Delete nutzen
\item falls zu viele deleted, dann neu hashen in gr{\"o}\ss erer Tabelle(amortisierte Laufzeit)
\end{itemize}

\subsection{Kuckuckshashing}
\begin{itemize}
\item 2 Hashfunktionen mit je einer Tabelle
\item Insert: Falls belegt, neuen Wert einf{\"u}gen und alten mit anderer Funktion neu hashen
\item max $d log(n)$ Hashversuche
\end{itemize}


\section{Graphentheorie}
\subsection{Adjazenzmatrix/liste}
\begin{itemize}
\item Zeile: von, Spalte: nach
\item Zeile: von, Eintr{\"a}ge: erreichende Knoten (einfach verkettete liste)
\end{itemize}

\subsection{SSSP}
\subsubsection{BFS}
\begin{itemize}
\item Kürzester Weg von s zu v, Zusammenhangskomponenten
\item BFS entdeckt alle Knoten $v\in V$, die von s aus erreichbar sind
\end{itemize}

\subsubsection{DFS}
\begin{itemize}
\item l{\"o}st nicht SSSP, bildet Spannbaum, entdeckt alle erreichbaren Knoten
\item G enth{\"a}lt einen Kreis $\Leftrightarrow$ DFS(G) erzeugt mindestens eine R{\"u}ckw{\"a}rtskante
\item DAG $\Leftrightarrow$ es existiert eine topologische Sortierung (alle Kanten einzeichnen)
\end{itemize}

\subsubsection{Dijkstra}
\begin{itemize}
\item setze Knoten auf $\infty$  au\ss er s und update adj(u) mit dem Gewicht, falls geringer 
\end{itemize}


\subsubsection{Bellman-Ford}
\begin{itemize}
\item $|V|-1$ Zeilen und Knoten als Spalten 
\item Gucke, ob neuer $Weg+E$ kleiner ist als alter Weg
\end{itemize}

\section{Uebersicht}
\subsection{Sortieralgos}
\begin{tabular}{c | c| c| c| c |c| c }
Algo & Art & InPlace & Stabilit{\"a}t & BC & AC & WC \\ \hline
Bubble& Vergleich& Ja & Ja & $\Theta(n)$ & $\Theta(n^2)$ & $\Theta(n^2)$\\
Insertion& Inkrementell & Ja & Ja & $\Theta(n)$ & $\Theta(n^2)$ & $\Theta(n^2)$ \\
Merge& $D\&C $ & Nein & Ja & $\Theta(nlog(n))$ & $\Theta(nlog(n))$ & $\Theta(nlog(n))$ \\
Quick& $D\&C $ & Ja & Nein & $\Theta(nlog(n))$ & $\Theta(nlog(n))$ & $\Theta(n^2)$ \\
Heap& $$ & Ja & Nein & $\Theta(nlog(n))$ & $\Theta(nlog(n))$ & $\Theta(nlog(n))$ \\
BuildHeap &&&&$\Theta(n)$&$\Theta(n)$&$\Theta(n)$ \\
Bucket& Inkrementell & Nein & Ja & $\Theta(n+k)$ & $\Theta(n+k)$ & $\Theta(n^2)$ \\

\end{tabular}

\subsection{Graphenalgos}

\begin{tabular}{c|c|c|c|c}

Algo & Laufzeit & Bedingung & Return & Funktionsweise \\ \hline
BFS &$|V|+|E|$ & keine Gew& Zshkompo & Queue\\
DFS& $|V|+|E|$ & keine Gew & Tiefenwald& Stack \\
Dijkstra& $(|V|+|E|)log(|V|)$ & no neg Gew& SSSP& vom min Koten updaten \\
BellmanFord& $|V|^2+|V|\cdot|E|$ &no neg Zyk &SSSP & Je Iteration Knoten  \\
&&&& abgehen, adj[Knoten] updaten\\ 
FloydWarshall& $|V|^3$ &no neg Zyk& APSP & Spalte/Reihe festhalten \\ 
Kruskal& $|E|\cdot log(|E|)$ & unger,zsmh& MST& min Kante \\ 
Prim& $|E| log(|V|)$ & unger,zsmh & MST& Baum wachsen lassen\\ 
\end{tabular}


\section{Rechentricks}
\begin{itemize}
\item Arithmetische Reihe $\sum_{i=1}^n k  = \frac{n(n+1)}{2} $
\item Geometrische Reihe $\sum_{i=0}^n q^i = \frac{1-q^{n+1}}{1-q}$
\item $log_a(P) = \frac{log_b(P)}{log_b(a)}$
\item $4^{log(n^2)} = 4^{2log(n)} =2^{4log(n)} = n^{4log(2)} = n^4 $




\end{itemize}

\end{document}