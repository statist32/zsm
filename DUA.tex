\documentclass{article}
\begin{document}
\section{Invariante}
\begin{itemize}
\item Vorm ersten Durchlauf erfüllt sein (Initialisierung, Induktionsanfang)
\item Muss bei jedem Schleifendurchlauf erhalten bleiben (Erhaltng, Induktionsschritt)
\item Invar nach Beendigung der Schleife zeigt Korrektheit (Terminierung)
\end{itemize}


\subsection{Rekursionsgleichungen}
\begin{itemize}
\item ineinander einsetzen
\item Summe erkennen und zusammengefasst aufschreiben
\end{itemize}
\subsection{Mastertheorem}
\subsubsection{Additives Mastertheorem}
\begin{itemize}
\item $ a,b,c \; positiv \; n= b^k$
\item $T (n) \leq \left\{
\begin{array}{ll}
c & n  = 1 \\
a\cdot T(\frac{n}{b}) +c & \, n>1 \\
\end{array}
\right. $
\end{itemize}
\begin{tabular}{l l  l}

$T(n) \leq c\cdot \frac{a}{a-1}n^{log_b(a)} - \frac{c}{a-1}  $&$= O(n^{log_b(a)}) $&$ \; falls \; a>1$ \\
$T(n) \leq c\cdot \frac{a}{a-1}n - \frac{c}{a-1} $&$ = O(n)  $& $\; falls \; a=b>1$\\
$T(n) \leq c\cdot log_b(n) +c  $&$= O(log(n)) $&$\; falls \; a=1$\\
\end{tabular}
\subsubsection {allgemeines Mastertheorem}
\begin{itemize}
\item $a,b,d,q \geq  1$
\item $T (n) \leq \left\{
\begin{array}{ll}
d & n\leq q \\
a\cdot T(\frac{n}{b}) +f(n) & \, n>q \\
\end{array}
\right. $
\end{itemize}
\begin{tabular}{l l}
$f(n) = O(n^{log_b(a)-\epsilon}) \; mit \; \epsilon > 0$ & $T(n) = O(n^{log_b(a)}) $\\
$f(n) = \Theta(n^{log_b(a)}) $ & $T(n) = O(n^{log_b(a)} log(n)) $\\
$f(n) = \Omega(n^{log_b(a)+\epsilon}) \; mit \; \epsilon > 0,$ & $T(n) = \Theta(f(n)) $\\
$a\cdot f(\frac{n}{b}) \leq \delta  \cdot f(n), \delta < 1, n \to \infty$ & \\
\end{tabular}

\section{ O-Notation}
\subsection{Definition}
\begin{itemize}
\item $f = O(g) \Leftrightarrow  \exists  c> 0 \exists n_0 \in N \; \forall n \geq n_0 : f(n) \leq c g(n)$ \newline (f wächst asymptotisch höchstens so schnell wie g)
\item $f = \Omega(g) \Leftrightarrow g = O(f)$ \newline (f wachst asymptotisch mindestens so schnell wie g)

\item f = $\Theta (g) \Leftrightarrow f = O(g) \; und \; g = O(f)$ \newline
(f und g wachsen asymptotisch gleich schnell)
\item $f = o(g) \Leftrightarrow \forall c > 0 \; \exists n_0 \in N \forall n\geq n_0 : f(n) < c g(n)$ \newline 
$ \lim\limits_{n \to \infty}\frac{f(n)}{g(n)} = 0 $\newline (f wächst asymptotisch langsamer als g)
\item $f = \omega(g) \Leftrightarrow g = o(f)$ \newline (f wächst asymptotisch langsamer als g)
\end{itemize}
\subsection{Eigenschaften}
\begin{itemize}
\item $f = o(g) \Rightarrow f = O(g)$
\item $f = o(g) \; und \;  h = o(g) \Rightarrow f+h = o(g) (auch O, \Omega, \omega, \Theta)$
\item $f = o(g) \; und \;  h = o(g) \Rightarrow f\cdot h = o(g^2) (auch O, \Omega, \omega, \Theta)$
\end{itemize}
\subsection{Reihenfolge}
$c < log(n) < n^{\frac{1}{k}} < n < n log(n) < n^2 < n^k < 2^n$
\section{Sortieralgorithmen}
\subsection {Bubblesort}
\begin{itemize}
\item Jeden Durchlauf wird das größte Element auf die n-ite Stelle getauscht. Jeder Vergleich ggf ein Swap.
\item inkrementelle, inplace, stabil
\item $BC: \Theta(n)\; AV: \Theta(n^2) \; WC: \Theta(n^2)$
\end{itemize}

\subsection{Insertionsort}
\begin{itemize}
\item Key wird in sortiertes Array eingeordnet. Key wird gemerkt, falls kleiner wird das gö\ss ere Element auf Pos von Key kopiert aber Key wird erst kopiert, wenn die richtige Stelle gefunden worden ist.
\item inkrementelle, inplace, stabil
\item $BC: \Theta(n)\; AV: \Theta(n^2) \; WC: \Theta(n^2)$ 
\end{itemize}

\subsection{Mergesort}
\begin{itemize}
\item Teile Array bis auf ein Element Array und sortiere beim rekursiven zusammenfügen. Geteilt wird p bis q, q+1 bis r. \newline
Merge vergleicht erste Pos von den Arrays und fügt immer das kleinere ins Zielarray ein.
\item D\&C, 
\item $BC: \Theta(nlog(n))\; AV:\Theta(nlog(n))\; WC: \Theta(nlog(n))\;$
\end{itemize}

\subsection{Quicksort(A,p,r)}
\begin{itemize}
\item Teile Array nach Pivotelement und füge Pivot dann an Grenze ein. Dann partition bis q-1 und 
\item D\&C, 
\item $BC: \Theta(nlog(n))\; AV:\Theta(nlog(n))\; WC: \Theta(n^2))\;$
\end{itemize}

\section{Heap}
\subsection{Definition}
$ Heap := A[i] \geq A[2i] und A[i] \geq A[2i+1]$ \newline
jeder Knoten hat mindestens so großen Wert wie seine Kinder \newline
Wird als binärer Baum dargestellt. \newline
\subsection{Eigenschafen}
\begin{itemize}
\item Baumtiefe $\lfloor log(n)\rfloor$
\item $A[\lfloor \frac{n}{2} \rfloor +1] \; bis \; A[n]$ sind Kinder
\item Maximum ist die Wurzel A[1]
\end{itemize}
\subsection{Build-Heap}
\subsection{Sort-Heap}










\section{Rechentricks}
\begin{itemize}
\item Arithmetische Reihe $\sum_{i=1}^n k  = \frac{n(n+1)}{2} $
\item logarithmus!!! bsp laufzeit aus probe 1

\end{itemize}

\end{document}